use std::ops::{Deref, Neg};

use crate::prelude::*;
use radix_engine_common::crypto::{Hash, IsHash};

/// This is a TEMPORARY workaround until Kotlin => ByteArray equatable issue for
/// Records has been solved, see: https://github.com/mozilla/uniffi-rs/issues/1980
///
/// A bytes collection that does NOT convert into `ByteArray` in Kotlin, but
/// instead `List<Byte>`, which has a working `==`.
#[derive(
    Clone,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Hash,
    SerializeDisplay,
    DeserializeFromStr,
    derive_more::Display,
    derive_more::Debug,
)]
#[display("{}", self.to_hex())]
#[debug("{}", self.to_hex())]
pub struct BagOfBytes {
    ///
    bytes: Vec<u8>,
}

impl Deref for BagOfBytes {
    type Target = Vec<u8>;

    fn deref(&self) -> &Self::Target {
        &self.bytes
    }
}

/// Expose `BagOfBytes` to Uniffi as `sequence<i8>`, unfortunately we cannot
/// use `sequence<u8>` because it results in:
///
/// /uniffi-rs-6f89edd2a1ffa4bd/fb8dd5c/uniffi_bindgen/src/interface/universe.rs:50:17:
/// assertion `left == right` failed
/// left: Custom { module_path: "profile", name: "BagOfBytes", builtin: Bytes }
/// right: Custom { module_path: "profile", name: "BagOfBytes", builtin: Sequence { inner_type: UInt8 } }
///
/// So HACK HACK HACK we use i8 instead
impl crate::UniffiCustomTypeConverter for BagOfBytes {
    type Builtin = Vec<i8>;

    fn into_custom(val: Self::Builtin) -> uniffi::Result<Self> {
        println!("Rust converting Vec<i8> -> BagOfBytes, Vec: '{:?}'", val);
        let from_builtin: Self = val
            .into_iter()
            // Two's complement
            .map(|i| (i.neg() as u8).wrapping_neg())
            .collect_vec()
            .into();
        println!("Rust converted to BagOfBytes: '{:?}'", from_builtin);
        Ok(from_builtin)
    }

    fn from_custom(obj: Self) -> Self::Builtin {
        println!(
            "Rust converting BagOfBytes -> Vec<i8>, BoB: '{:?}'",
            obj.to_vec()
        );
        let builtin = obj
            .to_vec()
            .into_iter()
            // Two's complement
            .map(|u| (u.wrapping_neg() as i8).neg())
            .collect_vec();
        println!("Rust converted to Vec<iu>: '{:?}'", builtin);
        builtin
    }
}

#[cfg(test)]
#[test]
fn test_twoscomplement_from_u8() {
    let x: u8 = 129;
    let y: i8 = (x.wrapping_neg() as i8).neg();
    assert_eq!(y, -127);
}

#[cfg(test)]
#[test]
fn test_twoscomplement_from_i8() {
    let x: i8 = -127;
    let y: u8 = (x.neg() as u8).wrapping_neg();
    assert_eq!(y, 129);
}

#[uniffi::export]
pub fn new_bag_of_bytes_129() -> BagOfBytes {
    BagOfBytes { bytes: vec![129] }
}

#[uniffi::export]
pub fn new_bag_of_bytes_from(bytes: Vec<u8>) -> BagOfBytes {
    bytes.into()
}

impl BagOfBytes {
    /// Instantiates a new `BagOfBytes` from bytes generated by
    /// a CSPRNG.
    pub fn generate() -> Self {
        generate_32_bytes().into()
    }
}

impl BagOfBytes {
    pub fn to_hex(&self) -> String {
        hex_encode(self.bytes())
    }
}

impl From<Hash> for BagOfBytes {
    /// Instantiates a new `BagOfBytes` from the `Hash` (32 bytes).
    fn from(value: Hash) -> Self {
        value.into_bytes().as_slice().into()
    }
}

impl From<Vec<u8>> for BagOfBytes {
    fn from(value: Vec<u8>) -> Self {
        Self { bytes: value }
    }
}
impl From<&[u8; 32]> for BagOfBytes {
    fn from(value: &[u8; 32]) -> Self {
        Self {
            bytes: value.to_vec(),
        }
    }
}
impl From<&[u8]> for BagOfBytes {
    /// Instantiates a new `BagOfBytes` from the bytes.
    fn from(value: &[u8]) -> Self {
        Self {
            bytes: value.to_vec(),
        }
    }
}

impl FromStr for BagOfBytes {
    type Err = CommonError;

    /// Tries to decode the string `s` into a `BagOfBytes`. Will fail
    /// if the string is not valid hex or if the decoded bytes does
    /// not have length 32.
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        hex_decode(s)
            .map_err(|_| CommonError::StringNotHex(s.to_owned()))
            .map(|v| v.into())
    }
}

impl HasPlaceholder for BagOfBytes {
    /// `deadbeef...``
    /// A placeholder used to facilitate unit tests.
    fn placeholder() -> Self {
        Self::placeholder_dead()
    }

    /// A placeholder used to facilitate unit tests.
    fn placeholder_other() -> Self {
        Self::placeholder_fade()
    }
}

impl BagOfBytes {
    /// `aced...``
    /// A placeholder used to facilitate unit tests.
    pub fn placeholder_aced() -> Self {
        Self::from_str(&"aced".repeat(16)).expect("aced...")
    }

    /// `babe...``
    /// A placeholder used to facilitate unit tests.
    pub fn placeholder_babe() -> Self {
        Self::from_str(&"babe".repeat(16)).expect("babe...")
    }

    /// `cafe...``
    /// A placeholder used to facilitate unit tests.
    pub fn placeholder_cafe() -> Self {
        Self::from_str(&"cafe".repeat(16)).expect("cafe...")
    }

    /// `dead...``
    /// A placeholder used to facilitate unit tests.
    pub fn placeholder_dead() -> Self {
        Self::from_str(&"dead".repeat(16)).expect("dead...")
    }

    /// `ecad...``
    /// A placeholder used to facilitate unit tests.
    pub fn placeholder_ecad() -> Self {
        Self::from_str(&"ecad".repeat(16)).expect("ecad...")
    }

    /// `fade...``
    /// A placeholder used to facilitate unit tests.
    pub fn placeholder_fade() -> Self {
        Self::from_str(&"fade".repeat(16)).expect("fade...")
    }
}

impl BagOfBytes {
    /// Returns a clone of the inner bytes as a `Vec`.
    pub fn to_vec(&self) -> Vec<u8> {
        Vec::from(self.bytes())
    }

    /// Returns a references to the inner array slice.
    pub fn bytes(&self) -> &[u8] {
        &self.bytes
    }
}

impl BagOfBytes {
    /// Tries to decode the string `s` into a `BagOfBytes`. Will fail
    /// if the string is not valid hex or if the decoded bytes does
    /// not have length 32.
    pub fn from_hex(s: &str) -> Result<Self> {
        Self::from_str(s)
    }
}

#[cfg(test)]
mod tests {

    use crate::prelude::*;

    #[test]
    fn equality() {
        assert_eq!(BagOfBytes::placeholder(), BagOfBytes::placeholder());
        assert_eq!(
            BagOfBytes::placeholder_other(),
            BagOfBytes::placeholder_other()
        );
    }

    #[test]
    fn inequality() {
        assert_ne!(BagOfBytes::placeholder(), BagOfBytes::placeholder_other());
    }

    #[test]
    fn from_string_roundtrip() {
        let str =
            "0000000000000000000000000000000000000000000000000000000000000000";
        assert_eq!(BagOfBytes::from_hex(str).unwrap().to_string(), str);
    }

    #[test]
    fn debug() {
        let str =
            "deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = BagOfBytes::placeholder();
        assert_eq!(format!("{:?}", hex_bytes), str);
    }

    #[test]
    fn display() {
        let str =
            "deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = BagOfBytes::placeholder();
        assert_eq!(format!("{}", hex_bytes), str);
    }

    #[test]
    fn to_hex() {
        let str =
            "deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = BagOfBytes::placeholder();
        assert_eq!(hex_bytes.to_string(), str);
    }

    #[test]
    fn json_roundtrip() {
        let model = BagOfBytes::placeholder();
        assert_json_value_eq_after_roundtrip(
            &model,
            json!("deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead"),
        );
    }

    #[test]
    fn json_roundtrip_fails_for_invalid() {
        assert_json_value_fails::<BagOfBytes>(json!("not even hex"));
    }

    #[test]
    fn from_bytes_roundtrip() {
        let bytes = &[0u8; 32];
        let data: BagOfBytes = bytes.into();
        assert_eq!(data.bytes(), bytes);
    }

    #[test]
    fn from_vec_roundtrip() {
        let vec = Vec::from([0u8; 32]);
        let sut: BagOfBytes = vec.clone().try_into().unwrap();
        assert_eq!(sut.to_vec(), vec);
    }

    #[test]
    fn invalid_str() {
        let s = "invalid str";
        assert_eq!(
            BagOfBytes::from_str(s),
            Err(CommonError::StringNotHex(s.to_owned()))
        );
    }

    #[test]
    fn random() {
        let mut set: HashSet<Vec<u8>> = HashSet::new();
        let n = 100;
        for _ in 0..n {
            let bytes = BagOfBytes::generate();
            set.insert(bytes.to_vec());
        }
        assert_eq!(set.len(), n);
    }
}

#[cfg(test)]
mod uniffi_tests {
    use crate::prelude::*;

    #[test]
    fn new_ok() {
        let bytes = generate_bytes::<5>();
        assert_eq!(new_bag_of_bytes_from(bytes.clone()).bytes, bytes);
    }
}
